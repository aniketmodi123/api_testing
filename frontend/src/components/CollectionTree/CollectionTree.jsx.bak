import { useEffect, useState } from 'react';
import { useNode } from '../../store/node';
import { useWorkspace } from '../../store/workspace';
import styles from './CollectionTree.module.css';

// Recursive component for rendering node items (folders and files)
const NodeItem = ({ 
  node, 
  expandedFolders, 
  toggleFolder, 
  handleDeleteNode, 
  handleSelectRequest, 
  selectedItem,
  getMethodColor, 
  level = 0 
}) => {
  // Maximum depth to prevent infinite recursion
  const MAX_LEVEL = 10;
  
  if (level > MAX_LEVEL) return null;
  
  if (node.type === 'folder') {
    return (
      <div className={`${styles.subFolder} ${level > 0 ? styles.nested : ''}`}>
        <div
          className={styles.folderHeader}
          onClick={() => toggleFolder(node.id)}
        >
          <span className={styles.expansionIcon}>
            {expandedFolders.includes(node.id) ? '‚ñº' : '‚ñ∂'}
          </span>
          <span className={styles.folderIcon}>üìÅ</span>
          <span className={styles.folderName}>{node.name}</span>
          <div className={styles.nodeActions}>
            <button
              className={styles.deleteButton}
              onClick={(e) => handleDeleteNode(node.id, e)}
              title="Delete"
            >
              üóëÔ∏è
            </button>
          </div>
        </div>
        
        {node.children && expandedFolders.includes(node.id) && (
          <div className={styles.folderItems}>
            {node.children.map(childNode => (
              <NodeItem
                key={childNode.id}
                node={childNode}
                expandedFolders={expandedFolders}
                toggleFolder={toggleFolder}
                handleDeleteNode={handleDeleteNode}
                handleSelectRequest={handleSelectRequest}
                selectedItem={selectedItem}
                getMethodColor={getMethodColor}
                level={level + 1}
              />
            ))}
          </div>
        )}
      </div>
    );
  } else {
    return (
      <div
        className={`${styles.requestItem} ${selectedItem === node.id ? styles.selected : ''}`}
        onClick={() => handleSelectRequest(node)}
      >
        <span
          className={styles.methodBadge}
          style={{
            backgroundColor: getMethodColor(node.method || 'GET'),
          }}
        >
          {node.method || 'GET'}
        </span>
        <span className={styles.requestName}>{node.name}</span>
        <div className={styles.nodeActions}>
          <button
            className={styles.deleteButton}
            onClick={(e) => handleDeleteNode(node.id, e)}
            title="Delete"
          >
            üóëÔ∏è
          </button>
        </div>
      </div>
    );
  }
};

// Fallback sample data if workspace tree is not available
const sampleCollections = [
  {
    id: 1,
    name: 'API Testing',
    items: [
      {
        id: 'folder-1',
        type: 'folder',
        name: 'Users API',
        items: [
          {
            id: 'req-1',
            type: 'request',
            method: 'GET',
            name: 'Get All Users',
            url: 'https://api.example.com/users',
          },
          {
            id: 'req-2',
            type: 'request',
            method: 'POST',
            name: 'Create User',
            url: 'https://api.example.com/users',
          },
        ],
      },
      {
        id: 'folder-2',
        type: 'folder',
        name: 'Products API',
        items: [
          {
            id: 'req-3',
            type: 'request',
            method: 'GET',
            name: 'Get All Products',
            url: 'https://api.example.com/products',
          },
        ],
      },
      {
        id: 'req-4',
        type: 'request',
        method: 'GET',
        name: 'Health Check',
        url: 'https://api.example.com/health',
      },
    ],
  },
  {
    id: 2,
    name: 'Workspace API',
    items: [
      {
        id: 'req-5',
        type: 'request',
        method: 'GET',
        name: 'List Workspace',
        url: 'https://api.example.com/workspace',
      },
    ],
  },
];

export default function CollectionTree({ onSelectRequest }) {
  const { activeWorkspace, loading: workspaceLoading } = useWorkspace();
  const {
    nodes,
    loading: nodeLoading,
    fetchNodesByWorkspaceId,
    createFolder,
    createFile,
    updateNode,
    deleteNode,
  } = useNode();

  const [expandedFolders, setExpandedFolders] = useState([]);
  const [selectedItem, setSelectedItem] = useState(null);
  const [isAddingFolder, setIsAddingFolder] = useState(false);
  const [newFolderName, setNewFolderName] = useState('');
  const [filterText, setFilterText] = useState('');

  // Fetch nodes when workspace changes
  useEffect(() => {
    if (activeWorkspace) {
      fetchNodesByWorkspaceId(activeWorkspace.id);
    }
  }, [activeWorkspace, fetchNodesByWorkspaceId]);

  // Use actual nodes or fallback to sample data
  const rootNodes =
    nodes.length > 0 ? nodes : activeWorkspace ? [] : sampleCollections;

  const toggleFolder = folderId => {
    setExpandedFolders(prev =>
      prev.includes(folderId)
        ? prev.filter(id => id !== folderId)
        : [...prev, folderId]
    );
  };

  const handleSelectRequest = request => {
    setSelectedItem(request.id);
    onSelectRequest && onSelectRequest(request);
  };

  const handleAddFolder = () => {
    setIsAddingFolder(true);
  };

  const handleCreateFolder = () => {
    if (newFolderName.trim() && activeWorkspace) {
      createFolder({
        name: newFolderName.trim(),
        workspace_id: activeWorkspace.id,
        parent_id: null, // Root level folder - use snake_case for API
      });
      setNewFolderName('');
      setIsAddingFolder(false);
    }
  };

  const handleCancelAddFolder = () => {
    setIsAddingFolder(false);
    setNewFolderName('');
  };

  const handleDeleteNode = (nodeId, e) => {
    e.stopPropagation();
    if (window.confirm('Are you sure you want to delete this item?')) {
      deleteNode(nodeId);
    }
  };

  // Filter nodes based on search text
  const filteredNodes =
    filterText.trim() === ''
      ? rootNodes
      : rootNodes.filter(node =>
          node.name.toLowerCase().includes(filterText.toLowerCase())
        );

  // Method badge color based on HTTP method
  const getMethodColor = method => {
    const methodColors = {
      GET: '#10b981', // Green
      POST: '#f97316', // Orange
      PUT: '#3b82f6', // Blue
      DELETE: '#ef4444', // Red
      PATCH: '#8b5cf6', // Purple
      HEAD: '#6b7280', // Gray
      OPTIONS: '#6b7280', // Gray
    };

    return methodColors[method] || '#6b7280';
  };

  return (
    <div className={styles.collectionTree}>
      <div className={styles.header}>
        <input
          type="text"
          placeholder="Filter"
          className={styles.filterInput}
          value={filterText}
          onChange={e => setFilterText(e.target.value)}
        />
        <button
          className={styles.addButton}
          onClick={handleAddFolder}
          title="Add new folder"
        >
          +
        </button>
      </div>

      <div className={styles.treeContainer}>
        {isAddingFolder && (
          <div className={styles.newFolderForm}>
            <input
              type="text"
              placeholder="Folder name"
              value={newFolderName}
              onChange={e => setNewFolderName(e.target.value)}
              autoFocus
              className={styles.newFolderInput}
            />
            <div className={styles.newFolderActions}>
              <button onClick={handleCreateFolder}>Create</button>
              <button onClick={handleCancelAddFolder}>Cancel</button>
            </div>
          </div>
        )}

        {(nodeLoading || workspaceLoading) && !rootNodes.length ? (
          <div className={styles.loadingState}>
            <p>Loading folders...</p>
          </div>
        ) : filteredNodes.length > 0 ? (
          filteredNodes.map(node => (
            <NodeItem 
              key={node.id}
              node={node}
              expandedFolders={expandedFolders}
              toggleFolder={toggleFolder}
              handleDeleteNode={handleDeleteNode}
              handleSelectRequest={handleSelectRequest}
              selectedItem={selectedItem}
              getMethodColor={getMethodColor}
            />
          ))

              {node.children && expandedFolders.includes(node.id) && (
                <div className={styles.folderItems}>
                  {node.children.map(childNode => (
                    <div key={childNode.id}>
                      {childNode.type === 'folder' ? (
                        <div
                          className={`${styles.subFolder} ${expandedFolders.includes(childNode.id) ? styles.expanded : ''}`}
                        >
                          <div
                            className={styles.folderHeader}
                            onClick={() => toggleFolder(childNode.id)}
                          >
                            <span className={styles.expansionIcon}>
                              {expandedFolders.includes(childNode.id)
                                ? '‚ñº'
                                : '‚ñ∂'}
                            </span>
                            <span className={styles.folderIcon}>ÔøΩ</span>
                            <span className={styles.folderName}>
                              {childNode.name}
                            </span>
                            <div className={styles.nodeActions}>
                              <button
                                className={styles.deleteButton}
                                onClick={e => handleDeleteNode(childNode.id, e)}
                                title="Delete"
                              >
                                üóëÔ∏è
                              </button>
                            </div>
                          </div>

                          {/* Recursive rendering for nested folders could be added here */}
                        </div>
                      ) : (
                        <div
                          className={`${styles.requestItem} ${selectedItem === childNode.id ? styles.selected : ''}`}
                          onClick={() => handleSelectRequest(childNode)}
                        >
                          <span
                            className={styles.methodBadge}
                            style={{
                              backgroundColor: getMethodColor(
                                childNode.method || 'GET'
                              ),
                            }}
                          >
                            {childNode.method || 'GET'}
                          </span>
                          <span className={styles.requestName}>
                            {childNode.name}
                          </span>
                          <div className={styles.nodeActions}>
                            <button
                              className={styles.deleteButton}
                              onClick={e => handleDeleteNode(childNode.id, e)}
                              title="Delete"
                            >
                              üóëÔ∏è
                            </button>
                          </div>
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              )}
            </div>
          ))
        ) : (
          <div className={styles.emptyState}>
            <p>
              {activeWorkspace ? 'No folders found' : 'No workspace selected'}
            </p>
            {activeWorkspace && (
              <button className={styles.createButton} onClick={handleAddFolder}>
                Create Folder
              </button>
            )}
          </div>
        )}
      </div>
    </div>
  );
}
